Category,Keywords,Problem_Description,Solution,Hint
Algorithm,"array,sort",請寫出由小到大排序的Quick Sort演算法,,
Graph,"tree,sort",給一個經過漸增排序後的陣列，將它轉換為高度平衡的二元搜索樹(BST),"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* n = NULL;
        bst(nums,0,nums.size()-1,n);
        return n;
    }
    void bst(vector<int>& nums,int i,int j,TreeNode* &n){
        if(i>j){
            return;
        }
        int mid = (i+j)/2;
        // cout<<nums[mid]<<endl;
        n = new TreeNode(nums[mid]);
        cout<<n->val<<endl;
        bst(nums,i,mid-1,n->left);
        bst(nums,mid+1,j,n->right);
    }
};//c++",
Function,type,"請實作下列四個函式，完成要求的輸出結果。

函式說明:
1. number_add: 有兩個int參數，回傳第一個int參數與另一個int參數相加的值
2. string_concat: 有兩個str參數，將第二個str參數連接到第一個str參數後回傳
3. list_append: 有list參數和str參數，將str參數連接到list的尾端回傳。
4. tuple_append: 有tuple參數和str參數，將str參數連接到tuple的尾端回傳。
","def number_add(n: int, v: int):
    return n + v
def string_concat(st: str, v: str):
    return st + v
def list_append(li: list, v: str):
    return li + [v,]
def tuple_append(t: tuple, v: str):
    return t + (v,)

num, s, s_list, s_tuple = 0, '', [], ()
for i in map(int, input().split()):
    num = number_add(num, i)
for i in input().split():
    s = string_concat(s, i)
for i in input().split():
    s_list = list_append(s_list, i)
for i in input().split():
    s_tuple = tuple_append(s_tuple, i)","def number_add(n: int, v: int):
    return n + v
def string_concat(st: str, v: str):
    return st + v
def list_append(li: list, v: str):
    return li + [v,]
def tuple_append(t: tuple, v: str):
    return t + (v,)
"
Function,type,"請嘗試利用範例題的函式list_append及tuple_append完成下列兩個與list和tuple相關的函式。

1. list_eval: 有兩個參數，list及int。複製list、並將參數int串接到複製list尾端後回傳該list，不改動作為參數的list

2. tuple_eval: 有兩個參數，tuple及int。複製tuple、將tuple中的每項接加上int參數的值後回傳該tuple，不改動作為參數的tuple
","def number_add(n: int, v: int):
    return n + v
def string_concat(st: str, v: str):
    return st + v
def list_append(li: list, v: str):
    return li + [v,]
def tuple_append(t: tuple, v: str):
    return t + (v,)

num, s, s_list, s_tuple = 0, '', [], ()
for i in map(int, input().split()):
    num = number_add(num, i)
for i in input().split():
    s = string_concat(s, i)
for i in input().split():
    s_list = list_append(s_list, i)
for i in input().split():
    s_tuple = tuple_append(s_tuple, i)

print(f'num is {num}\ns is {s}\ns_list is {s_list}\ns_tuple is {s_tuple}')

num_tuple = (1,2,3,4,5)

def list_eval(li: list, v: int):
    copied_list = li.copy()
    return list_append(copied_list, v)

def tuple_eval(t: tuple, v: int):
    copied_tuple = tuple(i + v for i in t)
    return copied_tuple


test1 = list_eval(s_list,'2')
test2 = tuple_eval(num_tuple,2)
print(test1)
print(test2)",
Algorithm,recursion,"知名的費波那契數列(Fibonacci Numbers)是指在一串數字中每一項皆為前兩項的和的數列，定義為 :
F_0=0
F_1=1
F_n=F_(n-1)+F_(n-2)   (n≥2)
其中F_n指的是數列中的第n項。
由此可得一數列: 0,1,1,2,3,5,8,13,...。請寫出能計算出該數列在某項值的程式。
","def fib(n):
    if n < 1:
        return 0
    elif n == 1:
        return 1    
    else:
        return fib(n - 1) + fib(n - 2)

print(fib(int(input())))
",
Algorithm,recursion,"接續上題，若有一個數列A的每項皆為F費波那契數列(Fibonacci Numbers) 至該項為止的總和，定義如下 :
A_0=F_0=0
A_1=A_0+F_1=0+1=1
A_2=A_1+F_2=1+1=2
A_n=A_(n-1)+F_n   (n≥1)
A_n指的是該數列中的第n項，F_n指的是費波那契數列的第n項。
請試著實作出符合上述定義的程式。
","def fib(n):
    if n < 1:
        return 0
    elif n == 1:
        return 1    
else:
        return fib(n - 1) + fib(n - 2)

def fib_acc(n):
    if n == 0:
        return 0
    return fib_acc(n-1) + fib(n)
print(fib_acc(int(input())))
",
Application,GUI,"請實作任一方式之GUI介面                                        須具備以下功能(不限呈現方式):
1. 視窗長寬為250px*150px
2. 標題(Title)為”Window” 
3. 視窗中顯示文字”Hello!”
","import tkinter as tk

class MyApp(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)       
        
        self.master.geometry('250x150')
        
        self.master.title('Window')
        
        self.MyLabel = tk.Label(self.master, text='Hello!')
        self.MyLabel.pack()
        
root = tk.Tk()
app = MyApp(master=root)
app.mainloop()
",
Application,GUI,"請實作任一方式之GUI介面
須具備以下功能(不限呈現方式):
1. 視窗長寬須大於400px*400px (可參考範例)
2. 標題(Title)改成小組所有成員之學號 (可參考範例)
3. 可以開啟指定檔案、並在畫面上顯示該開啟之檔名","import os
import tkinter as tk
from tkinter import filedialog as fd

class MyApp(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)       
        self.master.geometry('400x400')
        self.master.title('學號') 
        self.MyLabel = tk.Label(self.master, text='')
        self.MyLabel.pack()
        self.MyButton = tk.Button(self.master, text='open file', command=self.button_event)
        self.MyButton.pack()
    def button_event(self):
        f = fd.askopenfilename()
        
        self.MyLabel['text'] = os.path.basename(f)
               
root = tk.Tk()
app = MyApp(master=root)
app.mainloop()
",
Tool,array,"Numpy為針對高維度資料(陣列、矩陣)運算的函式庫，請利用此函式庫按照以下流程執行並輸出運算結果:
1. 接收一個數字N1、並利用產生出1~N1的ndarray(A1)，例如N1為5，便會得到[1 2 3 4]的ndarray。
2. 接收一個數字N2、並利用產生出1~N2的ndarray(A2)，例如N2為5，便會得到[1 2 3 4的ndarray。
3. 將A1轉成M×L之格式
4. 將A2轉成L×K之格式
5. 將A1及A2按照矩陣相乘成ndarray(A3)(dtype須為int) 


輸入 :
每個輸入依空格區隔分別依序為: N1、N2、M、L、K。 
N1、N2與矩陣內容相關，M、L、K與矩陣形狀相關，詳細參考上方題目說明。
輸出 :
由兩矩陣相乘後得出的矩陣。
","from numpy import arange
para = list(map(int, input().split()))
a1 = arange(1, para[0])
a2 = arange(1, para[1])
a1 = a1.reshape(para[2], para[3])
a2 = a2.reshape(para[3], para[4])
a3 = a1.dot(a2)

print(a3)
",
Tool,array,"Numpy為針對高維度資料(陣列、矩陣)運算的函式庫，請利用此函式庫按照以下流程執行並輸出運算結果:
1. 接收一個數字N、並利用產生出1~N的ndarray(A1)，例如N為5，便會得到[1 2 3 4]的ndarray。
2. 將A1轉成MxK的格式
3. 將A1複製(Deep Copy)到A2
4. 將A2中所有元素平方
5. 將A2轉成1×Row的格式。(如原本是2x2，便需轉換成1x4)
輸入 :
每個輸入依空格區隔分別依序為: N、M、K。
N與矩陣內容相關，M、K與矩陣形狀相關，詳細參考上方題目說明。
輸出:
輸出為A1和A2兩個矩陣","from numpy import arange
import numpy as np
para = list(map(int, input().split()))
a1 = arange(1, para[0])
a1 = a1.reshape(para[1], para[2])
a2 = np.copy(a1)
a2 = np.square(a2)
print(a1)
print(a2)",
